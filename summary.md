# 毕业总结

本次总结分为两个部分：第一部分是**数据结构**，对学习到的数据结构进行分类，同时给出对应的应用场景或者经典的题目；第二部分是**算法**，对学习到的算法进行分类；第三部分是需要刻意培养的**思维方式**。

## 一、数据结构

### 一维
+  基础
    + 数组（array）
    + 链表（linked list）
+ 高级
    + 栈（stack）：先入后出；相关题目有**括号匹配**、**直方图**
    + 队列（queue）：先入先出；相关题目有**滑动窗口**、**优先队列**、**堆排序**
    + 双端队列（deque）：在头部或者尾部做元素的进出；相关题目队列
    + 集合（set）：判断元素是否重复，有 hash set 和 tree set 的实现
    + 映射（map or hash）：经典的 key-valued 存储结构，同样有 hash map 和 tree map

    
### 二维
+ 基础
    + 树（tree）分层遍历（BFS）或者深度优先遍历
    + 图（graph）

+ 高级
    + 二叉搜索树（进一步演变出红黑树和 AVL），树也可以用来组成二叉堆（大顶堆和小顶堆）
    + 并查集（disjoin set）
    + 字典树（Trie）

### 特殊
+ 位运算（bitwise）：因为位运算是计算机底层的操作，所以一般实现的代码会比较简单；位运算可用于判重（N 皇后问题中搜索状态判重）；
    + 布隆过滤器
    + LRU Cache

### 时间复杂度
上述数据结构的时间复杂度可以在[Big-O-Cheet](https://www.bigocheatsheet.com/)网站获得

## 二、算法

### 基础组件
所有的算法都基于下述三个基础算法组件来构建：
+ 分支（branch）：if-else，switch
+ 循环（loop）：for，while，用于解决问题中关键的重复子问题
+ 递归（recursion）：用于解决问题中关键的重复子问题

### 搜索
+ 深度优先搜索（DFS）：基于栈实现的
+ 广度优先搜索（BFS）：基于队列实现的
+ A*：不使用栈，也不用队列，而是使用优先队列，就是 A* 启发式搜索

### 动态规划

寻找重复子问题时，发现子问题有最优解，同时可以在求解过程中淘汰次优解，那么这个问题就可以称为具有**最佳子结构**，那么就可以使用动态规划来求解

动态规划有两种做法：
1. 递归的方法，结合备忘录存储重复的子状态
2. 循环的方法，用数组存储所有的初始状态，然后用循环

### 二分查找

### 贪心算法

### 数学、几何问题

### **总结代码模板**

## 三、刻意培养的思维方式

### 化繁为简

    
